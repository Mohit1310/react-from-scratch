<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Day 4</title>
    <style>
        * {
            text-align: justify;
        }

        table {
            border-collapse: collapse;
            border: 1px solid;
        }

        th,
        td {
            text-align: left;
            padding: 8px;
            border: 1px solid;
        }

        th {
            background-color: #999;
        }

        .indentation {
            margin-left: 20px;
        }

        .indentation1 {
            margin-left: 40px;
        }

        pre {
            background-color: #f4f4f4;
            border: 1px solid #ccc;
            padding: 10px;
            overflow: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
        }
    </style>
</head>

<body>
    <h3>Is mandatory for React?</h3>
    <p>
        No, (JavaScript XML) is not mandatory for writing React applications, but it is highly recommended and
        widely used due to its benefits. is a syntax extension that allows you to write HTML-like code within
        JavaScript, making it easier to describe and visualize the structure of your UI components. <br>While you can
        write React applications using plain JavaScript without , doing so can make your code more verbose, harder to
        read, and less intuitive. simplifies the process of defining UI elements and their interactions with data by
        providing a declarative and expressive syntax.
    </p>
    <p>Here's an example of a simple React component written with and without :</p>
    <table>
        <tr>
            <th>
                <h4>With :</h4>
            </th>
            <th>
                <h4>Without :</h4>
            </th>
        </tr>
        <tbody>
            <td>
                <code>
                import React from 'react';<br><br>
                const MyComponent = () => {
                    <p class="indentation">return (</p>
                        <p class="indentation1">&lt;div&gt;</p>
                        <p class="indentation1">&lt;h1&gt;Hello, !&lt;/h1&gt;</p>
                        <p class="indentation1">&lt;p&gt;This is a React component with .&lt;/p&gt;</p>
                        <p class="indentation1">&lt;/div&gt;</p>
                    <p class="indentation">);</p>
                };
                <br>
                export default MyComponent;
                </code>
            </td>
            <td>
                <code>
                    import React from 'react';<br><br>
                    const MyComponent = () => {<br>
                    <p class="indentation">return React.createElement('div', null,</p>
                        <p class="indentation">React.createElement('h1', null, 'Hello, No !'),</p>
                        <p class="indentation">React.createElement('p', null, 'This is a React component without .')</p>
                    <p class="indentation">);</p>
                };
                <br>
                export default MyComponent;
                </code>
            </td>
        </tbody>
    </table>
    <hr>
    <h3>Is ES6 mandatory for React?</h3>
    <p>
        ES6 (ECMAScript 2015) is not mandatory for writing React applications, but it is highly recommended and widely
        used due to the modern JavaScript features and improvements it provides. React itself doesn't require you to use
        ES6, but leveraging ES6 features can significantly enhance your development experience and code quality.
    </p>
    <p>Few Reason's why ES6 is benificial</p>
    <ul>
        <li>Arrow Functions</li>
        <li>Classes</li>
        <li>Template literals</li>
        <li>Destructuring</li>
        <li>Spread and rest operators</li>
        <li>Modules</li>
        <li>Async/Await</li>
        <li>Let and Const</li>
        <li>Default parameters</li>
    </ul>
    <hr>
    <h3>How can I write comments in <code></code>?</h3>
    <p>As we know if we use "{}" we can write an js code inside brackets we can use "//...." for single line comment and
        "{/*...*/}" for multiline comments.</p>
    <hr>
    <h3>What is <code>&lt;React.Fragment&gt;&lt;/React.Fragment&gt;</code> and <code>&lt;&gt;&lt;/&gt;</code> ?</h3>
    <p>
        Both are used to create a component that doesn't render and additional DOM element. React.Fragment is a built in
        component while <code>&lt;&gt;&lt;/&gt;</code> is more concise syntax ('fragment shorthand') or empty tag. This
        is available from React 16.2, in React.fragment we can use '<b>key</b>' or other attributes but not in empty
        tag.
    </p>
    <hr>
    <h3>What is Virtual DOM?</h3>
    <p>
        Virtual DOM simple means a representation of actual DOM. This is used in libraries or frameworks such as React
        for UI rendering only rendering that element or let's say a new 'div' is added to your code instead of rendering
        the whole code react only renders the new added code. This process is called <i>reconcilliation</i>
    </p>
    <hr>
    <h3>What is Reconciliation in react?</h3>
    <p>
        We can also call it as <i>'Preserving and Resetting State'</i><br>
        <b>Defination: </b>The algorithm React uses to diff one tree with another to determine which parts need to be
        changed.
    </p>
    <hr>
    <h3>What is React Fiber?</h3>
    <p>
        It is basically a new and upcoming algorithm/architecture for react's diff algorithm for more we can read <a
            href="https://github.com/acdlite/react-fiber-architecture" target="_blank">here</a>.
    </p>
    <hr>
    <h3>Why we need keys in React?</h3>
    <p>
        The main purpose of keys is to help React differentiate and distinguish elements from each other, increasing its
        performance when diffing between the virtual and real DOM.
    </p>
    <hr>
    <h3>Can we use index as keys in React?</h3>
    <p>
        We can use them but it is not recommended and mostly we should not use them because that can cause rendering /
        re-rendering
        issue. Detailed article is <a href="https://robinpokorny.com/blog/index-as-a-key-is-an-anti-pattern/">here</a>.
    </p>
    <hr>
    <h3>What is props in React?</h3>
    <p>
        props (properties) in react are simply an arguments to the function. React components use props to communicate
        with each other. Every parent component can pass some information to its child components by giving them props.
        Props might remind you of HTML attributes, but you can pass any JavaScript value through them, including
        objects, arrays, and functions.
    </p>
    <hr>
    <h3>What is Config Driven UI?</h3>
    <p>
        For simple terms let's take example of <a href="https://www.swiggy.com/">Swiggy</a>. On the swiggy's website we
        can see a navbar, carousel which has offers and then the body and so on. Now inside the carousel the offers are
        different for every city some may have it some may don't and the data is rendered accordingly. So if a city has
        no offers then directly the body will appear after the navbar and no carousel. This type of rendering is known
        as Config Driven UI.
    </p>
    <hr>
    <h1>Day 5</h1>
    <h3>What is the difference between "Named" Export, "Default" export and "* as" export?</h3>
    <table>
        <tr>
            <th>Export Type</th>
            <th>Usage</th>
            <th>Import Syntax</th>
            <th>Example</th>
        </tr>
        <tr>
            <td>Named Export</td>
            <td>Export multiple values from a module with distinct names.</td>
            <td><code>import &#123; valueName &#125; from 'modulePath';</code></td>
            <td>
                <pre><code>    // Module: myModule.js
    export const name = 'John';
    export const age = 30;

    // Import in another file
    import &#123; name, age &#125; from './myModule';</code></pre>
            </td>
        </tr>
        <tr>
            <td>Default Export</td>
            <td>Export a single value as the default export of a module.</td>
            <td><code>import valueName from 'modulePath';</code></td>
            <td>
                <pre><code>    // Module: myModule.js
    const greeting = 'Hello';
    export default greeting;

    // Import in another file
    import greeting from './myModule';</code></pre>
            </td>
        </tr>
        <tr>
            <td>Namespace Export ("* as" Export)</td>
            <td>Export all values from a module as properties of an object.</td>
            <td><code>import * as moduleName from 'modulePath';</code></td>
            <td>
                <pre><code>    // Module: myModule.js
    export const name = 'Alice';
    export const age = 25;

    // Import in another file
    import * as myModule from './myModule';</code></pre>
            </td>
        </tr>
    </table>
    <hr>
    <h3>What is the importance of config.js/constants.js ?</h3>
    <p>
        <code><b>`config.js`</b></code> or <code><b>`constants.js`</b></code> files are often used in web development to
        centralize and manage configuration
        settings and constants within an application. These files play a crucial role in maintaining a clean codebase,
        improving maintainability, and making it easier to manage various aspects of your application.
    </p>
    <p>Here's the importance of using such files:</p>
    <ul>
        <li>Centralization</li>
        <li>Maintainability</li>
        <li>Readability</li>
        <li>Avoiding Magic Values</li>
        <li>Easy Updates</li>
        <li>Collaboration</li>
        <li>Testing</li>
    </ul>
    <hr>
    <h3>What are React Hooks ?</h3>
    <p>
        Hooks were introduced in React 16.8 as a way to simplify and improve the development experience of writing
        components by promoting more reusable and easier-to-understand code. Hooks addresses the need for better code
        organization, reusablity, and state management in functional components. <br>
    </p>
    <hr>
    <h3>Why do we need a `useState` Hook?</h3>
    <p>
        <code><b>useState</b></code> in react is used to manage the local state with functional components. It is like a
        variable a react. The main reason is to enable functional components to have dynamic, mutable state, which is
        crucial for building interactive and data-driven user interfaces.
    </p>
    <hr>
    <h1>Day 6</h1>
    <h3>What is Microservice ?</h3>
    <p>
        In a very simple way it's an approach to building software applications by breaking them down into smaller,
        loosely copupled, and independently deployable services. Each service represents a specific business capability
        and can be developed, deployed, and maintained independently. These services communicate with each other over a
        well-defined APIs, often through lightweight protocols such as HTTP or messaging systems.
    </p>
    <p>Key char's of Microservices are:</p>
    <ul>
        <li>Independence</li>
        <li>Scalability</li>
        <li>Flexibility</li>
        <li>Continous Deployment</li>
        <li>Complexity Management</li>
        <li>Etc.</li>
    </ul>
    <hr>
    <h3>what is Monolithic services?</h3>
    <p>
        It is an architectural style where the whole software application is built and deployed as a single,
        interconnected unit. In this application, all components and functionalities are tightly integrated within a
        single codebase, and the application typically shares a single database.
    </p>
    <p>Key char's of Microservices are:</p>
    <ul>
        <li>Single codebase</li>
        <li>single deployment</li>
        <li>Limited Scalability</li>
        <li>Risk of impact</li>
        <li>Development and Deployment challenges</li>
        <li>Etc.</li>
    </ul>
    <hr>
    <h3>What is the difference between Monolith and Microservice?</h3>
    <table>
        <tr>
            <th>Aspect</th>
            <th>Monolithic Architecture</th>
            <th>Microservices Architecture</th>
        </tr>
        <tr>
            <td>Structure</td>
            <td>Single codebase with tightly integrated components.</td>
            <td>Decomposed into small, loosely coupled services.</td>
        </tr>
        <tr>
            <td>Deployment</td>
            <td>Deployed as a single unit.</td>
            <td>Each service can be deployed independently.</td>
        </tr>
        <tr>
            <td>Communication</td>
            <td>Components communicate directly within the application.</td>
            <td>Services communicate over APIs, often using lightweight protocols.</td>
        </tr>
        <tr>
            <td>Scalability</td>
            <td>Scalability can be challenging due to all components being scaled together.</td>
            <td>Services can be scaled independently based on demand.</td>
        </tr>
        <tr>
            <td>Technology Stack</td>
            <td>Uses a single technology stack for the entire application.</td>
            <td>Allows different services to use different technology stacks.</td>
        </tr>
        <tr>
            <td>Development</td>
            <td>Tightly integrated development of all components.</td>
            <td>Services can be developed, deployed, and maintained independently.</td>
        </tr>
        <tr>
            <td>Maintenance</td>
            <td>Maintenance and updates can be complex due to the entire application being affected.</td>
            <td>Maintenance is easier as each service can be updated individually.</td>
        </tr>
        <tr>
            <td>Complexity</td>
            <td>Can become complex and unwieldy as the application grows.</td>
            <td>Allows for better management of complexity through smaller, focused services.</td>
        </tr>
        <tr>
            <td>Risk</td>
            <td>Changes in one part of the application can impact other parts.</td>
            <td>Changes in one service have limited impact on others due to loose coupling.</td>
        </tr>
    </table>
    <hr>
    <h3>Why do we need a useEffect Hook?</h3>
    <p>
        It is useed to manage data fetching and DOM manipulation, in functional components <br>
        <code>`useEffect`</code> is a hook to handle side effects in functional components. Side effects are actions
        that are not directly relate to rendering UI but can have an impact on the component's behavior.
    </p>
    <hr>
    <h3>What is Optional Chaining?</h3>
    <p>
        It is represented by <code>`<b>?.</b>`</code> syntax in JavaScript, is a feature that allows you to safely
        access nested properties and methods of an object without the need to check if each level of the property chain
        exists. It helps prevent "TypeError: Cannot read property 'x' of undefined" errors that occur when trying to
        access properties or methods on potentially undefined or null values.
    </p>
    <p>Basic idea of optional chaining:</p>
    <code>
    <pre>
    // Without Optional Chaining
    if (object && object.property && object.property.nestedProperty) {
        // Access nestedProperty
    }
    
    // With Optional Chaining
    const value = object?.property?.nestedProperty;</pre>
    </code>
    <p>
        In the example without optional chaining we would manually need to check at each level of the property chain
        before accessing the nested property, the <code>`<b>?.</b>`</code> operator handles these checks automatically
        and returns undefined if any part of the chain is undefined or null.
    </p>
    <p>Key points about optional chaining:</p>
    <ul>
        <li>Short-circuiting</li>
        <li>Functions</li>
        <li>Arrays</li>
        <li>Browser Compatibility</li>
    </ul>
    <p>Eg. of optional chaining:</p>
    <code>
        <pre>
    const user = {
        id: 1,
        name: 'John',
        address: {
            city: 'New York',
            zip: '10001'
        }
    };

    const cityName = user?.address?.city; // Accesses city safely
    const zipCode = user?.address?.zip;   // Accesses zip safely
    const country = user?.address?.country; // Returns undefined (no 'country' property)</pre>
    </code>
    <hr>
    <h3>What is Shimmer UI?</h3>
    <p>
        Well simple put it is the skeleton of the actual code. Like when first open for eg. cdr swiggy's website
        homepage before loading all the components we a skeleton layout of actual cards or any item so we understand
        that there is going to be a card something similar here. This provide a good user experience.
    </p>
    <hr>
    <h3>What is the difference between JS expression and JS statement</h3>
    <table>
        <tr>
            <th>Aspect</th>
            <th>JavaScript Expression</th>
            <th>JavaScript Statement</th>
        </tr>
        <tr>
            <td>Definition</td>
            <td>An expression is a piece of code that produces a value.</td>
            <td>A statement is a complete line of code that performs an action.</td>
        </tr>
        <tr>
            <td>Example</td>
            <td>
                <pre><code>5 + 3</code></pre>
            </td>
            <td>
                <pre><code>console.log('Hello, World!');</code></pre>
            </td>
        </tr>
        <tr>
            <td>Value</td>
            <td>Expressions have a value that can be assigned or used.</td>
            <td>Statements do not have a value to assign or use.</td>
        </tr>
        <tr>
            <td>Usage</td>
            <td>Can be used in assignments, function arguments, etc.</td>
            <td>Used for control flow (if, for, while), declarations (var, let, const), and actions (function calls).
            </td>
        </tr>
        <tr>
            <td>Side Effects</td>
            <td>Expressions can have side effects, but they are typically minimal.</td>
            <td>Statements often have more noticeable side effects, like changing variables or performing actions.</td>
        </tr>
    </table>
    <hr>
    <h3>What is Conditional Rendering, explain with a code example ?</h3>
    <p>
        Conditional rendering in React refers to the practice of rendering different content or components based on
        certain conditions. It allows you to display different UI elements depending on the state of your application or
        certain user interactions. <br><br> Here's an example:
    </p>
    <code>
        <pre>
    const App = () => {
        const isLoggedIn = true; // Example: User is logged in
    
        return (
            &lt;div&gt;
            &lt;h1&gt;Conditional Rendering Example&lt;/h1&gt;
            {isLoggedIn ? (
                &lt;p&gt;Welcome, User! &lt;/p&gt;
            ) : (
                &lt;p&gt;Please log in to continue.&lt;/p&gt;
            )}
            &lt;/div&gt;
        );
    };
    
    ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));
        </pre>
    </code>
    <hr>
    <h3>What is CORS?</h3>
    <p>
        It is a security feature implemented in web browsers to control and regulate the access to resources (such as
        fonts, images, APIs, and web services) across different origins (domains) on the internet. It prevents
        unauthorized access to resources hosted on one domain by scripts running on another domain. <br> CORS is
        particularly relevant when making requests from a web page hosted on one domain (origin) to an API or server
        hosted on a different domain. Without proper CORS configuration, web browsers would block these requests to
        prevent potential security vulnerabilities.
    </p>
    <p>Key points about CORS:</p>
    <ul>
        <li>Same-Origin Policy</li>
        <li>Cross-Origin Requests</li>
        <li>CORS Headers</li>
        <li>Preflight Requests</li>
        <li>Credentials</li>
        <li>Security</li>
    </ul>
    <p>
        Example of how CORS headers might be set on a server response to allow cross-origin requests:
    </p>
    <code>
        <pre>
    HTTP/1.1 200 OK
    Access-Control-Allow-Origin: https://www.example.com
    Access-Control-Allow-Methods: GET, POST, PUT
    Access-Control-Allow-Headers: Content-Type, Authorization
    Access-Control-Allow-Credentials: true</pre>
    </code>
    <p>
        In this example, the server indicates that requests from https://www.example.com are allowed, with certain HTTP
        methods and headers, and credentials can be included.
    </p>
    <hr>
    <h3>What is async and await?</h3>
    <p>
        <code>`<b>async</b>`</code> and <code>`<b>await</b>`</code> are features in JavaScript that simplify working
        with asynchronous code and Promises. They make
        asynchronous code look and behave more like synchronous code, improving readability and manageability. The async
        keyword is used to define asynchronous functions, and the await keyword is used within async functions to pause
        execution until a Promise is resolved. <br><br>Here's an example:
    </p>
    <code>
        <pre>
    // Using Promises without async/await
    function fetchData() {
    return fetch('https://api.example.com/data')
        .then(response => response.json())
        .catch(error => console.error(error));
    }

    fetchData().then(data => {
    console.log(data);
    });

    // Using async/await
    async function fetchDataAsync() {
        try {
            const response = await fetch('https://api.example.com/data');
            const data = await response.json();
            return data;
        } catch (error) {
            console.error(error);
        }
    }

    (async () => {
    const data = await fetchDataAsync();
    console.log(data);
    })();</pre>
    </code>
    <p>
        In the above example, we have a function <code>`<b>fetchData</b>`</code> that returns a Promise by using the
        <code>`<b>fetch</b>`</code> API. The
        traditional way to handle the Promise is by using .then() and .catch().
        <br><br>
        The second function, <code>`<b>fetchDataAsync</b>`</code>, is an <code>`<b>async</b>`</code> function that makes
        use of the <code>`<b>await</b>`</code>
        keyword within it. With
        <code>`<b>await</b>`</code>, we can pause the execution of the function until the Promise returned by
        <code>`<b>fetch</b>`</code> resolves. This makes the asynchronous code look similar to synchronous code.
        <br><br>
        Note that to use <code>`<b>await</b>`</code>, you need to be within an <code>`<b>async</b>`</code> function,
        which is why we're wrapping the calling code in
        an immediately-invoked asynchronous function in the example.
        <br><br>
        <code>`<b>async/await</b>`</code> offers improved code readability, easier error handling (with
        <code>`<b>try</b>`/`<b>catch</b>`</code>), and a more natural flow of control when dealing with asynchronous
        operations, making it a powerful tool for managing asynchronous code in a more synchronous-like manner.
        <br><br>
    </p>
    <hr>
    <h3>What is the use of `const json = await data.json();` in getRestaurants() in below code ?</h3>
    <code>
        <pre>
    async function getRestaurants() {
        const data = await fetch(
            "https://www.swiggy.com/dapi/..."
        );
        const json = await data.json();
        console.log("Fetched JSON:", json); // Log the fetched data
        //* Optional Chaining
        setAllRestaurants(
            json?.data?.cards[2]?.card?.card?.gridElements?.infoWithStyle?.restaurants
        );
        setFilteredRestaurants(
            json?.data?.cards[2]?.card?.card?.gridElements?.infoWithStyle?.restaurants
        );
    }</pre>
    </code>
    <b>Coding term:</b>
    <p>
        In the <code>`<b>getRestaurants()</b>`</code> function,
        <code><pre>`const json = await data.json();`</pre></code> takes the response from the
        <code>`<b>fetch</b>`</code>
        request and converts it into a usable form. Think of it like receiving a package. The
        <code>`<b>fetch</b>`</code> gets the package, but you can't use it directly. <code>`<b>data.json()</b>`</code>
        opens the package and reads what's inside (converting it from a special format called JSON to something your
        code understands). The <code>`<b>await</b>`</code> makes sure we
        wait for this process to finish. Then, the converted data is stored in the <code>`<b>json</b>`</code> variable.
        This is like getting the content of the package ready to use. You can now work with the content, like showing it
        on a screen or using it to update things in your code.
    </p>
    <b>Simple term:</b>
    <p>
        Fetching data from a website is similar to ordering food. You ask for information (data), but it takes time to
        arrive. The <code>`<b>await data.json();</b>`</code> line is like unpacking the delivered meal—making the data
        usable for your code. It's waiting for the website's response, turning it into something your code understands.
        Just as you can enjoy your meal after it's ready, your code can work with the data. The
        <code>`<b>json</b>`</code> variable now has the data, and you can show it on the screen or use it to update
        things. It's like enjoying the meal you ordered!
    </p>
    <hr>
    <h1>Day 7</h1>
    <h3>What are various ways to add images into our App? Explain with code examples.</h3>
    <p>There are 3 ways:</p>
    <h4>1. Using `<code>img</code>` Tag:</h4>
    <p>This is a standard HTML <code>&lt;img/&gt;</code> tag</p>
    <code>
        <pre>
    import React from 'react';

    const App = () => {
        return (
            &lt;div&gt;
            &lt;h1&gt;Using img Tag&lt;/h1&gt;
            &lt;img src="/path/to/image.jpg" alt="Sample" /&gt;
            &lt;/div&gt;
        );
    };

    export default App;</pre>
    </code>
    <h4>2. Imported Images:</h4>
    <p>We can import images directly into our React components and use them as variables.</p>
    <code>
        <pre>
    import React from 'react';
    import sampleImage from './path/to/image.jpg';

    const App = () => {
        return (
            &lt;div&gt;
            &lt;h1&gt;Importing Images&lt;/h1&gt;
            &lt;img src={sampleImage} alt="Sample" /&gt;
            &lt;/div&gt;
        );
    };

    export default App;</pre>
    </code>
    <h4>3. Using <code>public</code> folder:</h4>
    <p>We can place our images in public folder and use them directly</p>
    <code>
        <pre>
    import React from 'react';

    const App = () => {
        return (
            &lt;div&gt;
            &lt;h1&gt;Using public folder&lt;/h1&gt;
            &lt;img src="/image.jpg" alt="Sample" /&gt;
            &lt;/div&gt;
        );
    };

    export default App;</pre>
    </code>
    <p>
        Remember that in the third method, images placed in the `<code><b>public</b></code>` folder are treated as
        static assets, and you reference them without specifying the folder structure beyond the
        `<code><b>public</b></code>` directory.
    </p>
    <hr>
    <h3>What would happen if we do <code>console.log(useState())</code> ?</h3>
    <p>
        If you call `<code><b>console.log(useState())</b></code>`, it would show an array with two elements in the
        browser's console. The first element of the array would be the current state value, and the second element would
        be a function that you can use to update that state.
        <br>
        Here's an example of what the output might look like in the console:
        <code><b><pre>[initialStateValue, function]</pre></b></code>

        Let's break down what each part means:
        <br>
        - `<code><b>initialStateValue</b></code>`: This is the initial value you provide when you call the
        `<code><b>useState()</b></code>` function. It's the current value of the state. If you didn't pass any initial
        value, it would be `<code><b>undefined</b></code>` or whatever you set as the default.
        <br>
        - `<code><b>function</b></code>`: This is the updater function that you can use to change the state's value.
        When you call this function and provide a new value, React will re-render the component with the new state
        value.
        <br>
        For example, if you initially called `<code><b>useState('Hello')</b></code>`, the output of
        `<code><b>console.log(useState())</b></code>` might look like this:
        <code><pre><b>["Hello", function]</b></pre></code>
        Keep in mind that you usually don't call `<code><b>useState()</b></code>` directly like this. Instead, you use
        it inside a functional component and use destructuring to extract the state value and updater function
        separately:
        <br>
        <code><pre><b>const [stateValue, setStateValue] = useState(initialState);</b></pre></code>
        This helps you work with the state more conveniently and clearly in your component.
    </p>
    <hr>
    <h3>How will useEffect behave if we don't add a dependency array ?</h3>
    <p>It will get called everytime we are updating the ui i.e. any change in state.</p>
    <hr>
    <h3>What is SPA?</h3>
    <p>
        A Single Page Application (SPA) is a type of web application that interacts with the user by dynamically
        rewriting the current page rather than loading entire new pages from the server. In simple terms the whole
        application is just one pagae and no page gets refreshed everytime we navigate.
    </p>
    <hr>
    <h3>What is difference between Client Side Routing and Server Side Routing?</h3>
    <table>
        <tr>
            <th>Aspect</th>
            <th>Client-Side Routing</th>
            <th>Server-Side Routing</th>
        </tr>
        <tr>
            <td>Definition</td>
            <td>Routing is handled within the browser using JavaScript. Navigation triggers updates to the DOM without
                full page reloads.</td>
            <td>Routing is managed by the server. Each navigation request typically involves a full page reload.</td>
        </tr>
        <tr>
            <td>Page Load</td>
            <td>Initial page load retrieves a basic HTML shell, and additional content is fetched and rendered using
                JavaScript.</td>
            <td>Each navigation request triggers a complete page load from the server with the necessary content.</td>
        </tr>
        <tr>
            <td>Performance</td>
            <td>Improves performance by reducing server requests. Can lead to faster transitions between pages once
                initial load is complete.</td>
            <td>May have slower navigation due to full page reloads, especially on larger websites.</td>
        </tr>
        <tr>
            <td>Browser History</td>
            <td>Uses client-side routing libraries to manage browser history and maintain the appearance of multiple
                pages.</td>
            <td>Each navigation request creates a new entry in the browser history, allowing for easy back/forward
                navigation.</td>
        </tr>
        <tr>
            <td>SEO</td>
            <td>Initially problematic for SEO due to search engines not executing JavaScript. Can be mitigated using
                server-side rendering (SSR) or pre-rendering.</td>
            <td>Generally more SEO-friendly since content is fully available to search engine crawlers during initial
                page load.</td>
        </tr>
        <tr>
            <td>URL Structure</td>
            <td>Uses hash-based URLs or HTML5 History API for clean URLs without full page reloads.</td>
            <td>Uses traditional URLs that map directly to server resources.</td>
        </tr>
        <tr>
            <td>Interactivity</td>
            <td>Provides smoother user experience with dynamic transitions and animations between pages.</td>
            <td>May require additional interactivity scripting to enhance user experience during full page reloads.</td>
        </tr>
    </table>
    <hr>
    <h1>Day 8</h1>
    <h3>How do you create Nested Routes react-router-dom cofiguration?</h3>
    <p>We use a npm library <code>`<b>react-router-dom</b>`</code> and below is the code of how we use it</p>
    <p>
        <code>
            <pre>
    const appRouter = createBrowserRouter([
        {
            path: "/",
            element: &lt;AppLayout /&gt;,
            errorElement: &lt;Error /&gt;,
            children: [
                {
                    path: "/",
                    element: &lt;Body /&gt;,
                },
                {
                    path: "/about",
                    element: &lt;About /&gt;,
                    children: [
                        {
                            path: "profile",  // "/about/profile"
                            element: &lt;ProfileClass /&gt;
                        }
                    ]
                },
                {
                    path: "/contact",
                    element: &lt;Contact /&gt;,
                },
                {
                    path: "/restaurant/:resId", // "/restaurant/1234"
                    element: &lt;RestaurantMenu /&gt;,
                },
            ],
        },
        {
            path: "/login",
            element: &lt;Login /&gt;,
        },
    ]);</pre>
        </code>
    </p>
    <hr>
    <h3>What is the order of life cycle method calls in Class Based Components?</h3>
    <div>
        <img src="./src/assets/img/react-lifecycle.png" alt="react-lifecycle-diagram" width="100%"
            title="Credit: https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" />
    </div>
    <hr>
    <h3>Why do we use <code>componentDidMount</code>?</h3>
    <p>It is a best method we use for API calling in class based component.</p>
    <hr>
    <h3>Why do we use <code>componentWillUnmount</code>? Show with example.</h3>
    <p>
        We use it to clear the state or to stop the function of that component when we navigate to another component.
        <br><br> Below is the code eg.
    </p>
    <code>
        <pre>
    componentDidMount() {
        this.timer = setInterval(() => {
            console.log("Class Timer Running");
        }, 1000);
    }
    
    componentWillUnmount() {
        clearInterval(this.timer);
    }</pre>
    </code>
    <p>
        In the above eg. if we don't use <code>`<b>componentWillUnmount</b>`</code> the
        <code>`<b>setInterval</b>`</code> will keep on running and website may break. That's why we use
        <code>`<b>componentWillUnmount</b>`</code>
    </p>
    <hr>
    <h3>(Research) Why do we use <code><b>super(props)</b></code> in constructor?</h3>
    <p>
        In React class components, the `<code><b>super(props)</b></code>` call is used within the constructor to
        initialize the parent class's constructor and pass the <code><b>`props`</b></code> object to it. This is
        necessary because when you create a class that extends another class (in this case, your React component class
        extending <code><b>`React.Component`</b></code>), you need to make sure that the base class's constructor is
        called before you can access any properties or methods defined in that base class.
        <br><br>
        Here's a breakdown of why `<code><b>super(props)</b></code>` is used:
        <br><br>
        1. <b>Inheritance</b>: React class components are usually defined by extending the
        <code><b>`React.Component`</b></code> class or one of its subclasses. When you create a subclass, you're
        essentially inheriting the properties and methods of the parent class.
        <br><br>
        2. <b>Constructor</b> The <code><b>`constructor`</b></code> is a special method that's executed when an instance
        of a class is created. It's used to initialize the object's properties and perform setup tasks.
        <br><br>
        3. <b>Super Constructor</b>: When you extend a class, your subclass can have its own constructor. However,
        before you can use <code><b>`this`</b></code> in your subclass's constructor, you need to call the constructor
        of the parent class (the base class). This is where `<code><b>super(props)</b></code>` comes in.
        <br><br>
        - <code><b>`super()`</b></code>: Calling <code><b>`super()`</b></code> without any arguments will invoke the
        constructor of the parent class with no arguments. If the parent class's constructor requires arguments (like
        <code><b>`props`</b></code> in this case), this will result in an error.
        <br><br>
        - `<code><b>super(props)</b></code>`: By passing <code><b>`props`</b></code> to <code><b>`super()`</b></code>,
        you're essentially calling the constructor of the parent class (e.g., <code><b>`React.Component`</b></code>)
        with the <code><b>`props`</b></code> object. This allows the parent class to properly initialize its properties
        related to props and sets up the necessary environment for your subclass.
        <br><br>
        Here's an example of how it's used:
        <code>
            <pre>
    class MyComponent extends React.Component {
        constructor(props) {
        <code><b>super(props)</b></code>; // Call the constructor of the parent class (React.Component) with props
        // Now you can use this.props in your component
        }

        render() {
        // ...
        }
    }</pre>
        </code>

        In modern React, you don't actually need to explicitly call `<code><b>super(props)</b></code>` unless you need
        to access <code><b>`this.props`</b></code> in your constructor. If you don't need to do that, React will
        automatically call <code><b>`super()`</b></code> for you behind the scenes.

        Keep in mind that React has introduced function components with hooks as a more modern way of building
        components, and class components are becoming less common in newer React codebases.
    </p>
    <hr>
    <h3>(Research) Why can't we have the callback function of useEffect async?</h3>
    <p>
        The callback function of <code><b>`useEffect`</b></code> cannot be declared as <code><b>`async`</b></code>
        because <code><b>`useEffect`</b></code> expects the callback to
        either return nothing or a cleanup function. If the callback is declared as <code><b>`async`</b></code>, it
        implicitly returns a
        <code><b>`Promise`</b></code>, which is not compatible with the expected return types.
        <br><br>
        Example:
        <br>
        <code>
                <pre>
        // This is incorrect and will lead to unexpected behavior
        useEffect(async () => {
            const data = await fetchData(); // fetchData returns a Promise
            setData(data);
        }, []);</pre>
            </code>

        In this example, the <code><b>`useEffect`</b></code> callback is declared as <code><b>`async`</b></code>, and
        it's using <code><b>`await`</b></code> inside it. However,
        <code><b>`useEffect`</b></code> doesn't handle Promises returned by the async callback as expected, and it may
        lead to issues like
        delayed updates or memory leaks.
        <br>
        To work with asynchronous operations inside <code><b>`useEffect`</b></code>, you should call an async function
        inside the callback:
        <code>
                <pre>
        useEffect(() => {
            const fetchDataAsync = async () => {
                const data = await fetchData();
                setData(data);
            };
    
            fetchDataAsync();
        }, []);</pre>
            </code>
        By defining an async function within the <code><b>`useEffect`</b></code> callback and then calling it
        immediately, you ensure proper
        handling of asynchronous operations without breaking the expected behavior of <code><b>`useEffect`</b></code>.
    </p>
    <hr>
</body>

</html>